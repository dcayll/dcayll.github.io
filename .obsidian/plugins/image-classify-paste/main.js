/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCPPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var import_path = require("path");
var path = {
  // Credit: @creationix/path.js
  join(...partSegments) {
    let parts = [];
    for (let i = 0, l = partSegments.length; i < l; i++) {
      parts = parts.concat(partSegments[i].split("/"));
    }
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
      const part = parts[i];
      if (!part || part === ".")
        continue;
      else
        newParts.push(part);
    }
    if (parts[0] === "")
      newParts.unshift("");
    return newParts.join("/");
  },
  // returns the last part of a path, e.g. 'foo.jpg'
  basename(fullpath) {
    const sp = fullpath.split("/");
    return sp[sp.length - 1];
  },
  filename(fullpath) {
    let filename = (0, import_path.basename)(fullpath);
    return filename.substring(0, filename.indexOf("."));
  }
  // return extension without dot, e.g. 'jpg'
  // extension(fullpath: string): string {
  // 	const positions = [...fullpath.matchAll(new RegExp('\\.', 'gi'))].map(a => a.index)
  // 	return  fullpath.slice(positions[positions.length - 1] + 1)
  // },
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var defaultSettings = Object.freeze({
  shouldConfirmBeforeCreate: true,
  // weekStart: "locale" as IWeekStartOption,
  wordsPerDot: "DEFAULT_WORDS_PER_DOT",
  showWeeklyNote: false,
  weeklyNoteFormat: "",
  weeklyNoteTemplate: "",
  weeklyNoteFolder: "",
  localeOverride: "system-default"
});
var PasteSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h1", { text: "Paste Image Option" });
    this.containerEl.createEl("p", { text: "Github repo link: " }).createEl("a", {
      text: "Paste Image Plugin\u{1F385}",
      href: "https://github.com/ostoe/Ob-ImagePastePlugin"
    });
    this.containerEl.createEl("h3", {
      text: "When Insert"
    });
    this.containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "Positions and rules saved when pasting or inserting"
    });
    this.addPastePathSetting();
    this.addPastePathInputSetting();
    this.addApplyRuleOnlineImageSetting();
    this.addApplyRuleToLocalImageSetting();
    this.containerEl.createEl("h3", {
      text: "Preferred lmage Syntax"
    });
    this.containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "You can find following options to config which pattern of markdown source will be generated when insert images."
    });
    this.addImageRelativePathSetting();
    this.addSpecialFormat1RelativePathSetting();
    this.addEscapeURLPathSetting();
    this.containerEl.createEl("h3", {
      text: "Advanced Settings"
    });
  }
  ////////////////////////
  // 
  addPastePathSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Select Image Save Path").setDesc(
      "Choose what day of the week to start. Select 'Locale default' to use the default specified by moment.js"
    ).addDropdown((dropdown) => {
      var PasteOptions = {
        default: "Default",
        current: "Copy image to current folder (./)",
        toassets: "Copy image to ./assets",
        tofilenameassests: "Copy image to ./${filename}.assets",
        // "Upload image",
        tocustom: "Copy image to custom folder"
      };
      dropdown.addOptions(PasteOptions);
      dropdown.setValue(this.plugin.settings.PasteImageOption).onChange((value) => {
        var _a;
        this.plugin.settings.PasteImageOption = value;
        console.log(value);
        (_a = this.inputEI) == null ? void 0 : _a.setDisabled(!(this.plugin.settings.IsShowCustomPath = value == "tocustom"));
      });
    });
  }
  // addPastePathInputSetting
  addPastePathInputSetting() {
    var _a;
    new import_obsidian2.Setting(this.containerEl).setDesc(
      createFragment((e) => {
        const text = e.createDiv("admonition-convert");
        (0, import_obsidian2.setIcon)(text.createSpan(), "admonition-warning");
        text.createSpan({
          text: "This "
        });
        text.createEl("strong", { text: "will" });
        text.createSpan({
          text: " modify notes. Use at your own risk and please make backups."
        });
        e.createEl("p", {
          // text: "With large vaults, this could take awhile!"
        });
      })
    ).addText((textfield) => {
      this.inputEI = textfield;
      textfield.setPlaceholder(String("defaulltss"));
      textfield.setValue(this.plugin.settings.CustomPath);
      textfield.onChange(async (value) => {
        this.plugin.settings.CustomPath = value;
        this.plugin.writeOptions("12424323" + value);
      });
    });
    (_a = this.inputEI) == null ? void 0 : _a.setDisabled(!this.plugin.settings.IsShowCustomPath);
  }
  addApplyRuleOnlineImageSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Apply Rule To Online Image Setting").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.IsApplyNetworklImage);
      toggle.onChange(async (value) => {
        this.plugin.settings.IsApplyNetworklImage = value;
        this.plugin.writeOptions("onChange" + value);
      });
    });
  }
  addApplyRuleToLocalImageSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Apply Rule To Local Image Setting").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.IsApplyLocalImage);
      toggle.onChange(async (value) => {
        this.plugin.settings.IsApplyLocalImage = value;
        this.plugin.writeOptions("onChange" + value);
      });
    });
  }
  /////////////////////////////////
  addImageRelativePathSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Use relative path if possible").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.IsRelativePath);
      toggle.onChange(async (value) => {
        this.plugin.settings.IsRelativePath = value;
        this.plugin.writeOptions("onChange" + value);
      });
    });
  }
  addSpecialFormat1RelativePathSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Add ./ for relative path").setDesc("When enabled, Typora will use pattern like ./assets/image.png instead ofassets/imagepng when generating relative path for inserted images.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.IsAddRelativePath);
      toggle.onChange(async (value) => {
        this.plugin.settings.IsAddRelativePath = value;
        this.plugin.writeOptions("onChange" + value);
      });
    });
  }
  addEscapeURLPathSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Auto escape image URL when insert").setDesc(`For example, if you insert a file at 'img/example file.png', it will become"img/example%20file.png' Enable this for better compatibility with otherMarkdown engines, or disable this for better readability. ItWill affect formatting/restructuring commands`).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.IsEscapeUriPath);
      toggle.onChange(async (value) => {
        this.plugin.settings.IsEscapeUriPath = value;
        this.plugin.writeOptions("onChange" + value);
      });
    });
  }
  addDotThresholdSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Auto escape image URL when insert").setDesc(`For example, if you insert a file at 'img/example file.png', it will become"img/example%20file.png' Enable this for better compatibility with otherMarkdown engines, or disable this for better readability. ItWill affect formatting/restructuring commands`).addToggle((toggle) => {
      toggle.setValue(true);
      toggle.onChange(async (value) => {
        this.plugin.writeOptions("onChange");
      });
    });
  }
  addConfirmCreateSetting() {
    new import_obsidian2.Setting(this.containerEl).setName("Confirm before creating new note").setDesc("Show a confirmation modal before creating a new note").addText((textfield) => {
      textfield.setPlaceholder(String("defaulltss"));
      textfield.inputEl.type = "number";
      textfield.setValue(String("this.plugin.options.wordsPerDot"));
      textfield.onChange(async (value) => {
        this.plugin.writeOptions("12424323");
      });
    });
  }
};

// src/main.ts
var reg1 = /!\[\[(.*?)\]\]/;
var DEFAULT_SETTINGS = {
  defaultSetting: "default",
  imageNamePattern: "{{fileName}}",
  dupNumberAtStart: false,
  dupNumberDelimiter: "-",
  dupNumberAlways: false,
  autoRename: false,
  handleAllAttachments: false,
  excludeExtensionPattern: "",
  disableRenameNotice: false,
  IsShowCustomPath: false,
  PasteImageOption: "default",
  CustomPath: "./",
  IsEscapeUriPath: true,
  IsAddRelativePath: true,
  IsApplyLocalImage: true,
  IsApplyNetworklImage: true,
  IsRelativePath: false
};
var IMAGE_EXTS = [
  "jpg",
  "jpeg",
  "png",
  "gif",
  "bmp",
  "svg"
];
var ImageCPPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.insertTextList = [];
    this.imageIndex = 0;
    this.customPasteEventCallback = async (evt, editor, markdownView) => {
      var _a, _b, _c;
      this.imageNameList = [];
      this.insertTextList = [];
      this.imageIndex = 0;
      const t_types = (_a = evt.clipboardData) == null ? void 0 : _a.types;
      if ((t_types == null ? void 0 : t_types.length) == 1 && t_types[0] === "text/plain") {
        return;
      }
      this.MDTFile = markdownView.file;
      if ((t_types == null ? void 0 : t_types.length) == 2 && t_types[0] === "text/html" && t_types[1] === "Files") {
        const items = (_b = evt.clipboardData) == null ? void 0 : _b.items;
        if ((items == null ? void 0 : items.length) == 2 && items[1].kind == "file" && items[1].type.startsWith("image/")) {
          let extension = items[1].type.split("/")[1];
          items[0].getAsString((s) => {
            let imageName;
            const result = s.match(this.researchFromImageSrc);
            if (result) {
              let filename;
              if (result.length === 2) {
                filename = result[1];
              } else if (result.length == 4 && result[1] && result[2]) {
                filename = result[1];
              } else {
                filename = result[3];
              }
              const url = new URL(filename);
              imageName = url.pathname.split("/").last();
              if (!(imageName == null ? void 0 : imageName.endsWith(extension))) {
                imageName += `.${extension}`;
              } else {
                new import_obsidian3.Notice("\u89E3\u6790\u56FE\u7247\u540D\u5931\u8D25\uFF0C\u4F7F\u7528\u968F\u673A\u540D");
              }
            }
            this.imageNameList.push({
              type: "network",
              filename: imageName || `image-${getFormatNow()}.${extension}`
            });
          });
        }
      } else if ((t_types == null ? void 0 : t_types.length) == 1 && t_types[0] === "Files") {
        if (!((_c = evt.clipboardData) == null ? void 0 : _c.files))
          return;
        const files = evt.clipboardData.files;
        for (var i = 0; i < files.length; i += 1) {
          if (files[i].type.startsWith("image/") && files[i].name.length > 0) {
            let extension = files[i].type.split("/")[1];
            this.imageNameList.push({
              type: "local",
              filename: files[i].name === "image.png" ? "image-" + getFormatNow() + "." + extension : files[i].name
            });
          } else {
            this.imageNameList.push({ type: "nai", filename: "" });
          }
        }
      }
    };
  }
  writeOptions(arg0) {
    console.log(arg0);
  }
  async onload() {
    await this.loadSettings();
    if (import_obsidian3.Platform.isWin) {
      this.researchFromImageSrc = /<img src="(.*?)" alt="(.*?)"\/><|<img src="(.*?)"\/></;
    } else if (import_obsidian3.Platform.isMacOS) {
      this.researchFromImageSrc = /<img src="(.*?)"\/>$/;
    }
    this.addCommand({
      id: "re-construt-image",
      name: "reconstrut-image: Make images placed using standard markdown syntax, Be sure to back up your files before performing this operation",
      editorCallback: async (editor, ctx) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (markdownView) {
          await this.resolveAllImageInMD();
          return true;
        }
      }
    });
    this.addSettingTab(new PasteSettingsTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian3.TFile))
          return;
        const timeGapMs = new Date().getTime() - file.stat.ctime;
        if (timeGapMs > 1e3)
          return;
        if (isMarkdownFile(file))
          return;
        if (file instanceof import_obsidian3.TFile) {
          if (this.imageNameList == null || this.imageNameList.length === 0) {
            return;
          } else if (this.imageNameList.length === 1 && this.imageNameList[0].type === "network") {
            console.log("----------------------", this.imageNameList[0], file.basename, file.name, file.path);
            this.pasteOneImage2MDDir(this.imageNameList[0], file);
          } else if (this.imageNameList.length >= 1 && this.imageNameList[this.imageIndex].type != "nai") {
            let image = this.imageNameList[this.imageIndex];
            this.pasteMultipleImage2MDDir(image, file);
            this.imageIndex++;
          }
        }
      })
    );
    this.registerEvent(this.app.workspace.on("editor-paste", this.customPasteEventCallback));
  }
  // get a image link with a standard markdown syntax.
  // examplle:
  // input: (MdFile, "test.jpg")  
  // output:    [ "MDFile.filename/test.jpg", "![test](MDFIle.filename/test.jpg)"]
  async getRenameFilePath(mdFile, filename) {
    var _a, _b, _c;
    let dirPath;
    switch (this.settings.PasteImageOption) {
      case "current":
        dirPath = "./";
        break;
      case "toassets":
        dirPath = "./assets";
        break;
      case "tofilenameassests":
        dirPath = ((_a = mdFile.parent) == null ? void 0 : _a.path) ? path.join(mdFile.parent.path, mdFile.basename) : mdFile.basename;
        dirPath += ".assets";
        break;
      case "tocustom":
        if (this.settings.CustomPath.startsWith("./")) {
          if (this.settings.CustomPath.contains("${filename}")) {
            dirPath = this.settings.CustomPath.replace(/\$\{filename\}/g, mdFile.basename);
          } else {
            dirPath = this.settings.CustomPath;
          }
          break;
        }
      default:
        dirPath = ((_b = mdFile.parent) == null ? void 0 : _b.path) ? path.join(mdFile.parent.path, mdFile.basename) : mdFile.basename;
    }
    console.log((_c = mdFile.parent) == null ? void 0 : _c.path, mdFile.basename, dirPath);
    if (this.settings.PasteImageOption != "current" && !await this.app.vault.adapter.exists(dirPath)) {
      console.log("not exist, will create");
      await this.app.vault.createFolder(dirPath);
    }
    let newImagePath = path.join(dirPath, filename);
    let newFilename = filename;
    if (await this.app.vault.adapter.exists(newImagePath)) {
      newFilename = filename.substring(0, filename.lastIndexOf(".")) + "-" + getFormatNow() + filename.substring(filename.lastIndexOf("."));
      newImagePath = path.join(dirPath, newFilename);
    }
    const linkName = this.settings.IsEscapeUriPath ? encodeURI(path.join(dirPath, newFilename)) : path.join(dirPath, newFilename);
    const IsAddRelativePath = this.settings.IsAddRelativePath ? "" : "";
    const newLinkText = "![" + newFilename + "](" + IsAddRelativePath + linkName + ")";
    console.log("new:", this.settings.IsAddRelativePath, IsAddRelativePath, newLinkText, linkName);
    return [newImagePath, newLinkText];
  }
  async pasteOneImage2MDDir(pasteImageInfo, image) {
    if (!pasteImageInfo || !this.MDTFile)
      return;
    const [newImagePath, newLinkText] = await this.getRenameFilePath(this.MDTFile, pasteImageInfo.filename);
    const sourcePath = this.getActiveFile().path;
    const editor = this.getActiveEditor(sourcePath);
    if (!editor) {
      new import_obsidian3.Notice(`Failed to rename ${sourcePath}: no active editor`);
      return;
    }
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const imageOriNameLength = line.substring(0, cursor.ch).endsWith("]]") ? image.name.length + 5 : encodeURI(image.name).toString().length + 5;
    console.log(cursor.ch, line, line.length, newLinkText.length, imageOriNameLength, image.name, image.name.length + 5, encodeURI(image.name).toString().length + 5);
    await this.app.vault.rename(image, newImagePath);
    editor.replaceRange(newLinkText, { ...cursor, ch: cursor.ch - imageOriNameLength }, { ...cursor, ch: cursor.ch });
  }
  async pasteMultipleImage2MDDir(pasteImageInfo, image) {
    var _a;
    if (!pasteImageInfo || !this.MDTFile)
      return;
    const dirPath = ((_a = this.MDTFile.parent) == null ? void 0 : _a.path) ? path.join(this.MDTFile.parent.path, this.MDTFile.basename) : this.MDTFile.basename;
    const filename = pasteImageInfo.filename;
    const srcLinkText = this.app.fileManager.generateMarkdownLink(image, path.join(dirPath, filename));
    const [newImagePath, newLinkText] = await this.getRenameFilePath(this.MDTFile, pasteImageInfo.filename);
    const sourcePath = this.getActiveFile().path;
    const editor = this.getActiveEditor(sourcePath);
    if (!editor) {
      new import_obsidian3.Notice(`Failed to rename ${sourcePath}: no active editor`);
      return;
    }
    this.app.vault.rename(image, newImagePath);
    if (this.insertTextList.length === this.imageNameList.length - 1) {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const lastStartInsertLine = cursor.line - (this.imageNameList.length - 1) * 2;
      const lastStartInsertLineContent = editor.getLine(lastStartInsertLine);
      var sp = { line: 0, ch: 0 };
      if (this.insertTextList.length != 0) {
        if (lastStartInsertLineContent === this.insertTextList[0].src) {
          sp = { line: lastStartInsertLine, ch: 0 };
        } else if (lastStartInsertLineContent.endsWith(this.insertTextList[0].src) && lastStartInsertLineContent.length >= this.insertTextList[0].src.length) {
          sp = { line: lastStartInsertLine, ch: lastStartInsertLineContent.length - this.insertTextList[0].src.length };
        }
        var content = this.insertTextList.map((x) => x.dst).join("\n\n") + "\n\n" + newLinkText + "\n";
      } else {
        sp.ch = cursor.ch - srcLinkText.length;
        sp.line = cursor.line;
        var content = newLinkText;
      }
      console.log(cursor.ch, cursor.line, line, srcLinkText, newImagePath);
      editor.replaceRange(content, { line: sp.line, ch: sp.ch }, cursor);
    } else {
      this.insertTextList.push({ src: srcLinkText, dst: newLinkText });
    }
  }
  async resolveAllImageInMD() {
    var _a;
    const mdFile = this.app.workspace.getActiveFile();
    const editor = this.getActiveEditor(mdFile.path);
    if (!editor || !mdFile)
      return;
    const fileCache = this.app.metadataCache.getFileCache(mdFile);
    if (!((_a = fileCache == null ? void 0 : fileCache.embeds) == null ? void 0 : _a.length))
      return;
    const embeds = [];
    for (var i = fileCache.embeds.length - 1; i >= 0; i--) {
      const e = fileCache.embeds[i];
      embeds.push({
        link: e.link,
        sline: e.position.start.line,
        sch: e.position.start.col,
        eline: e.position.end.line,
        ech: e.position.end.col,
        origin: e.original
      });
    }
    for (var i = 0; i < embeds.length; i++) {
      const embed = embeds[i];
      if (!reg1.test(embed.origin) || !isImageWithLink(embed.link)) {
        console.log("\u4E0D\u7528\u8FC1\u79FB: ", embed.origin, reg1.test(embed.origin));
        continue;
      }
      const linkRename = embed.link.split(" ").join("-");
      const [newImagePath, newLinkText] = await this.getRenameFilePath(mdFile, linkRename);
      const imgfile = this.app.metadataCache.getFirstLinkpathDest(embed.link, mdFile.path);
      if (!imgfile) {
      } else {
        await this.app.vault.rename(imgfile, newImagePath);
      }
      editor.replaceRange(
        newLinkText,
        { line: embed.sline, ch: embed.sch },
        { line: embed.eline, ch: embed.ech }
      );
    }
    new import_obsidian3.Notice("Resolve Images Link Completed");
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.imageFileNames = Object.assign([]);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getActiveFile() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    const file = view == null ? void 0 : view.file;
    return file;
  }
  getActiveEditor(sourcePath) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (view == null ? void 0 : view.file) {
      if (view.file.path == sourcePath) {
        return view.editor;
      }
    }
    return null;
  }
};
function getFormatNow() {
  const d = new Date();
  return `${d.getFullYear()}${d.getMonth() + 1}${d.getDate()}${d.getMinutes()}${d.getSeconds()}${d.getMilliseconds()}`;
}
function isMarkdownFile(file) {
  if (file instanceof import_obsidian3.TFile) {
    if (file.extension === "md") {
      return true;
    }
  }
  return false;
}
function isImageWithLink(link) {
  return IMAGE_EXTS.contains(link.split(".").last().toLowerCase());
}
//!(process.env.BUILD_ENV === 'production')
